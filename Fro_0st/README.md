**Название задания:** Всегда найдётся азиат...

**Описание:** Только закончил читать книгу ThinkPython, почувствовал себя богом, так сказать... Как тут объявляется этот тип и внаглую издевается над моим скиллом. Но я докажу ему, что мы тоже не пальцем деланные!

![task](https://github.com/SharLike-CTF-Team/AltayCTF-2017/blob/master/Fro_0st/1.jpg)
 
Игрокам дан скрипт на языке python (.py) и изображение. В скрипте используются библиотеки для работы с изображениями и их преобразованием (PIL). Можно сделать вывод, что изображение получили с помощью этого скрипта. Задача – найти исходное изображение. Код частично обфусцирован – названия некоторых переменных заменены на иероглифы, есть две функции непонятного назначения. Все иероглифы можно перевести любым переводчиком с китайского языка на русский, получив их название и примерный смысл. Следующий этап – разобраться с двумя странными функциями:
```
1.)	def 折(a,b):
  return a if b == 0 else 折(a^b, (a&b)<<1)
2.)	def 乘(a,b):
  return 0 if b==0 else 折((a if ((b&1) == 1) else 0), 乘(a<<1,b>>1))
```
Первая функция переводится как «сумма», вызвав её с различными числовыми аргументами можно понять, что она действительно просто складывает числа.
Вторая функция – умножение, использует для своих вычислений функцию суммы.
Заменяем все вызовы этих функций на простые операции сложения и умножения. 
Преобразование проводилось в главной функции (3), аргументы – исходное изображение, преобразованное, и размер изображения (изображение квадратное).
3.)	Функция преобразования:

```
def 卷曲蜗牛(源, 接受者, 大小):
    n = 大小
    dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]
    x, y, c = 0, -1, 1
    ws, hs = 0, 0
    for i in range(折(n,n) - 1):
        for j in range((乘(折(n,n),2) - 乘(i, 2)) // 4):
            x += dx[i % 4]
            y += dy[i % 4]
            接受者[ws,hs] = 源[x,y] 
            ws = ws + 1
            if ws > n-1: ws, hs = 0, 折(hs,1)
    return 接受者
```

Можно выполнить функцию для своих данных – любого двумерного массива, и увидеть, по какому принципу происходит обход пикселей. После проведения анализа становится понятно, что исходное изображение «обошли по спирали», записывая пиксели в строки изображения, данного игрокам. Код решения приводить не буду – всё довольно просто, и пойти можно даже несколькими путями.
Полученное исходное изображение:

![solved](https://github.com/SharLike-CTF-Team/AltayCTF-2017/blob/master/Fro_0st/2.jpg)
 
****************
**Название**: Скрытый

**Описание**: Очень странное задание мне выдали вместо капчи
 
![task](https://github.com/SharLike-CTF-Team/AltayCTF-2017/blob/master/Fro_0st/3.jpg)

Игрокам дано изображение формата .jpeg. Также известно, что категория – стеганография. Название также намекает на то, что в изображении скрыты какие-то данные. Скрывать данные в файлах, подвергающихся сжатию с потерями, довольно сложно, и количество методов скрытия также ограничено. 
  - дописывание данных скрываемой информации в конец файла 
  - скрытие информации между блоками данных файла.
  - скрытие информации в косвенных данных файла для скрытия зашифрованной информации 
  - скрытие информации с использованием таблиц квантования - собственно именно этот метод использовался
Для получения скрытой информации можно было воспользоваться open-source утилитой stegdetect (https://github.com/abeluck/stegdetect).

****************
**Название**: Самозащита

**Описание**: Младший брат сказал, что написал какую-то умную систему для проверки защищённости любого компьютера. Я-то знаю, что ничего серьёзного он сделать не мог, но всё же интересно, что там внутри

Игрокам дана папка с исполняемыми файлами и библиотеками. Имеется два .exe файла:
Server.exe – написанное на python и скомпилированное с помощью cx_freeze консольное приложение, представляющее собой сокет-сервер, прослушивающий на локальном порту и ожидающий подключений.
App.exe – написанное на python с использованием qt и скомпилированное с помощью cx_freeze GUI приложение, представляющее собой клиента. При нажатии на кнопку заполняется полоса прогресса. После того, как она доходит до 66%, клиент пытается подключиться на порт, прослушиваемый server.exe, и начинается обмен данными.
 
![img](https://github.com/SharLike-CTF-Team/AltayCTF-2017/blob/master/Fro_0st/4.png)

Данные посылаются абсолютно одинаковые. Начало передачи и конец отмечаются специальными сигналами. Игрокам требуется понять, что два приложения взаимодействуют между собой. Сделать это можно, воспользовавшись смекалкой, подсказками, логикой, или применив навыки реверс-инженеринга. 
Следующий шаг – записать дамп трафика с локального порта и проанализировать его. Между сигналами неодинаковая задержка – иногда больше, иногда меньше, но всегда фиксированные значения. Длинную задержку стоит принять за «тире», короткую – за «точку», и расшифровать сообщение, посланное азбукой Морзе.

****************
**Название**: Наглец

**Описание**: Вечно он опаздывает. Бабушка заболела, кошка рожает, в сельских пробках застрял. Что на этот раз?
Игрокам дан ```.docx``` файл, подписанный цифровой подписью. Просмотрев свойства подписи, можно найти флаг.
 
![solve](https://github.com/SharLike-CTF-Team/AltayCTF-2017/blob/master/Fro_0st/5.png)
 
****************
**Название**: WannaTry

**Описание**: 
На волне распространения шифровальщиков подруга подхватила какую-то гадость:(
krasotka99: привет Паш, у меня тут проблемки
krasotka99: из бухгалтерии скинули какой-то отчёт, не могу его открыть
krasotka99: чем открыть .py?
krasotka99: Ой всё!! сама нашла, ну спасибо за игнор, я этого не забуду!
krasotka99: АААа
krasotka99: что такое биткоины?
krasotka99: Паааш, хочешь в кафе сходим? А потом ко мне домой, с ноутбуком что-то случилось :(

Игрокам дан скомпилированный python файл. Просмотрев его «magic number», можно узнать версию python-a, на которой происходила компиляция (3.6). Как известно, для python 3 и выше на данный момент не существует декомпиляторов, поэтому нужно было догадаться импортировать файл в интерактивной консоли и просмотреть, какие действия доступны.

```>>> import WannaTry
WannaTry.py [at line:6] ERROR      [2017-07-02 21:42:19,803]  CANNOT GET DATA FROM SERVER
>>> dir(WannaTry)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'connect', 'decrypt', 'enable_log_level', 'get_token', 'hack', 'log', 'main', 'pickle', 'randomize', 'some', 'trY', 'what_are_you_searching_here']
```

Вызываем функцию 'enable_log_level' с аргументом True, количество выводимой логгером информации увеличивается. Остаётся только вызвать функцию hack().
```
>>> WannaTry.enable_log_level(1)
>>> WannaTry.hack()
WannaTry.py [at line:37] WARNING    [2017-07-02 21:43:50,449]  Cannot connect to server with token Altay{you_did_it}
False
```

****************
**Название**: Мальчики направо, девочки налево

**Описание**: Жаль, что я не пошёл на ту вечеринку. Ну хоть фотки скинули, может там есть что интересное. ДА ОНИ СОВСЕМ ИЗДЕВАЮТСЯ! Взяли, и зашифровали какой-то непонятной штукой, да ещё и размер в два раза увеличился.

Игрокам дан зашифрованный файл формата «img.png.enc». Из названия следует, что формат изображения был .png. Так как сказано, что исходный размер увеличился в два раза, попробуем разбить файл на две равные части и просмотрим первые байты. Все PNG файлы начинаются с единой одинаковой сигнатуры, следовательно, мы знаем, какие байты хотим получить (‰PNG 89 50 4E 47). В шифровании очень распространена операция XOR – сложение по модулю 2. Попробуем сделать XOR между двумя первыми байтами двух полученных блоков – и получим 89 – первый байт сигнатуры. Для второго байта результат не совпал, для третьего совпал. Возможно, чётные байты нужно получать иначе – можно попробовать сложить их, тогда всё совпадёт. Написав скрипт для выполнения двух этих действий над байтами, можно получить исходное изображение. Само же исходное изображение было «зашифровано» с помощью такого алгоритма:
```
import random as r
inp = open("inp.png", 'rb').read()
l = len(inp)
o1 = list()
o2 = list()
for a in range(l):
	if a % 2 == 0:
		next1 = r.randint(0, inp[a] // 2)
		next2 = next1 ^ inp[a]
	else:
		next1 = r.randint(0, inp[a])
		next2 = inp[a] - next1
	o1.append(next1)
	o2.append(next2)
out = open('file.out', 'wb')
out.write(bytes(o1))
out.write(bytes(o2))
out.close()
```
Скрипт для решения:
```
inp = open("file.out", 'rb').read()
l = len(inp)
p1 = inp[:(l // 2)]
p2 = inp[(l // 2):]
res = open('res.jpeg', 'wb')
r = list()

for a in range(l // 2):
	if a % 2 == 0:
		r.append(p1[a] ^ p2[a])
	else:
		r.append(p1[a] + p2[a])
res.write(bytes(r))
res.close()
```

![flag](https://github.com/SharLike-CTF-Team/AltayCTF-2017/blob/master/Fro_0st/6.png)

****************
**Название**: Паранойя

**Описание**: Они повсюду, они следят за мной.

Игрокам дан .pcap дамп трафика. Среди прочих протоколов передачи в нём встречаются USB и USBMS. Какие-то данные передавались через USB. Можно извлечь их – получим несколько мелодий, исполняемый файл и текстовый документ с единственной строчкой:
```
admin: 1c0b76fce779f78f51be339c49445c49
```
Можно понять, что это пара имя пользователя: пароль/хеш пароля (32 байта с высокой энтропией).
Используя открытые базы, по хешу находится исходный пароль «secure». Алгоритм – md5.
Теперь осталось узнать, куда вводить эту связку логин:пароль. Просмотрев статистику по остальным пакетам, можно увидеть соединения на ip без домена на необычный порт. Перейдя по тому же адресу, видно форму входа. Введя в неё полученные ранее данные, игроки получают «флаг».

****************
**Название**: Зовите Томми!

**Описание**: Всё просто: я послал к тебе коня с флагом. Он скачет по пустынным полям, так что можно не бояться за сохранность доставки.
 
![cigano](https://github.com/SharLike-CTF-Team/AltayCTF-2017/blob/master/Fro_0st/7.jpg)

Проявив смекалку и немного вспомнив стереотипы, можно было понять, что флага нет. Последняя подсказка прямо говорила об этом: «Его больше нет». Осталось ввести пустой флаг, следуя единому формату на соревнованиях: `Altay{}`.

****************
**Название**: За что мне всё это?

**Описание**: «Зачем скидывать обычные файлы? Нееет, я отправлю их в raw формате, и ещё упакую в подарок.»
Игрокам дан двоичный файл неизвестного содержания и назначения. Тем, кто знаком с широко распространённой структурой хранения TLV (tag/type-length-value), было несложно распознать наличие тегов, следующих за ним значений длин в байтах и самих контейнеров значений. Во всём файле длина тега – 2 байта, длины – 4 байта.  После «разложения» всего файла на составляющие, видно, что имеется два больших файла, у каждого есть описание («RawPSDImage000», «RawAudioFile00»), характеристики («w:1920-h:1080-m:32b/c», «f:32bitfloat,SR:96000, mono»), версия, 32 байта с высокой энтропией – вероятнее всего, хеш-сумма. Сами файлы открыть невозможно – оказывается, что они каким-либо образом модифицированы. Энтропия очень высокая. 
Сравним содержимое этих файлов и увидим, что в начале их байты различаются лишь в некоторых местах по одинаковым сдвигам, повторяющихся фрагментов нет. Хорошо знакомые с криптографией люди могут предположить, что оба файла была зашифрованы симметричным шифром с константным ключом в режиме генератора гаммы. При таком шифровании в качестве ключа-инициализатора генератора псевдослучайных чисел используется кодовое слово, затем создаётся гамма такой же длины, как и длина шифруемого файла. Байты гаммы XOR’ятся с шифруемым файлом. Алгоритм довольно прост. 
В таком случае, чтобы получить гамму и расшифровать один файл полностью, второй частично (длина raw-аудио в 2 раза меньше), XOR’им два зашифрованных файла.
Наша задача – просмотреть изображение (расшифрованное наполовину). Так как это формат RAW и никаких служебных заголовков нет, мы можем просто дописать в конце любые байты, чтобы увеличить размер файла до исходного. После этого открываем изображение, в свойствах вписываем данные нам параметры (w:1920-h:1080-m:32b/c) и получаем флаг.
 
При увеличении изображения символы чётко видны.

![flag](https://github.com/SharLike-CTF-Team/AltayCTF-2017/blob/master/Fro_0st/8.png)
